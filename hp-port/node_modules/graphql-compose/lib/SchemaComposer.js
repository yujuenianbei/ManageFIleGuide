'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SchemaComposer = undefined;

var _graphql = require('./graphql');

var _TypeStorage = require('./TypeStorage');

var _TypeMapper = require('./TypeMapper');

var _TypeComposer2 = require('./TypeComposer');

var _InputTypeComposer2 = require('./InputTypeComposer');

var _EnumTypeComposer2 = require('./EnumTypeComposer');

var _Resolver2 = require('./Resolver');

var _is = require('./utils/is');

/*  strict */
/* eslint-disable class-methods-use-this */

class SchemaComposer extends _TypeStorage.TypeStorage {

  constructor() {
    super();
    const schema = this;

    class TypeComposer extends _TypeComposer2.TypeComposer {}
    TypeComposer.schemaComposer = schema;
    this.TypeComposer = TypeComposer;

    class InputTypeComposer extends _InputTypeComposer2.InputTypeComposer {}
    InputTypeComposer.schemaComposer = schema;
    this.InputTypeComposer = InputTypeComposer;

    class Resolver extends _Resolver2.Resolver {}
    Resolver.schemaComposer = schema;
    this.Resolver = Resolver;

    class EnumTypeComposer extends _EnumTypeComposer2.EnumTypeComposer {}
    EnumTypeComposer.schemaComposer = schema;
    this.EnumTypeComposer = EnumTypeComposer;

    this.typeMapper = new _TypeMapper.TypeMapper(schema);

    // alive proper Flow type casting in autosuggestions
    /* :: return this; */
  }

  rootQuery() {
    return this.getOrCreateTC('Query');
  }

  rootMutation() {
    return this.getOrCreateTC('Mutation');
  }

  rootSubscription() {
    return this.getOrCreateTC('Subscription');
  }

  buildSchema() {
    const roots = {};

    if (this.has('Query')) {
      const tc = this.getTC('Query');
      this.removeEmptyTypes(tc, new Set());
      roots.query = tc.getType();
    }

    if (this.has('Mutation')) {
      const tc = this.getTC('Mutation');
      this.removeEmptyTypes(tc, new Set());
      roots.mutation = tc.getType();
    }

    if (this.has('Subscription')) {
      const tc = this.getTC('Subscription');
      this.removeEmptyTypes(tc, new Set());
      roots.subscription = tc.getType();
    }

    if (Object.keys(roots).length === 0) {
      throw new Error('Can not build schema. Must be initialized at least one ' + 'of the following types: Query, Mutation, Subscription.');
    }

    return new _graphql.GraphQLSchema(roots);
  }

  removeEmptyTypes(typeComposer, passedTypes = new Set()) {
    const fields = typeComposer.getFields();
    Object.keys(fields).forEach(fieldName => {
      const fieldType = fields[fieldName].type;
      if (fieldType instanceof _graphql.GraphQLObjectType) {
        const typeName = fieldType.name;
        if (!passedTypes.has(typeName)) {
          passedTypes.add(typeName);
          const tc = new this.TypeComposer(fieldType);
          if (Object.keys(tc.getFields()).length > 0) {
            this.removeEmptyTypes(tc, passedTypes);
          } else {
            // eslint-disable-next-line
            console.log(`GQC: Delete field '${typeComposer.getTypeName()}.${fieldName}' ` + `with type '${tc.getTypeName()}', cause it does not have fields.`);
            delete fields[fieldName];
          }
        }
      }
    });
    typeComposer.setFields(fields);
  }

  getOrCreateTC(typeName, onCreate) {
    if (!this.hasInstance(typeName, _TypeComposer2.TypeComposer)) {
      const tc = this.TypeComposer.create(typeName);
      this.set(typeName, tc);
      if (onCreate && (0, _is.isFunction)(onCreate)) onCreate(tc);
    }
    return this.get(typeName);
  }

  getOrCreateITC(typeName, onCreate) {
    if (!this.hasInstance(typeName, _InputTypeComposer2.InputTypeComposer)) {
      const itc = this.InputTypeComposer.create(typeName);
      this.set(typeName, itc);
      if (onCreate && (0, _is.isFunction)(onCreate)) onCreate(itc);
    }
    return this.get(typeName);
  }

  getOrCreateETC(typeName, onCreate) {
    if (!this.hasInstance(typeName, _EnumTypeComposer2.EnumTypeComposer)) {
      const etc = this.EnumTypeComposer.create(typeName);
      this.set(typeName, etc);
      if (onCreate && (0, _is.isFunction)(onCreate)) onCreate(etc);
    }
    return this.get(typeName);
  }

  // disable redundant noise in console.logs
  toString() {
    return 'SchemaComposer';
  }
  toJSON() {
    return 'SchemaComposer';
  }
  inspect() {
    return 'SchemaComposer';
  }
}
exports.SchemaComposer = SchemaComposer;