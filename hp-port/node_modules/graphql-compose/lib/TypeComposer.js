'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TypeComposer = undefined;

var _extends2 = require('babel-runtime/helpers/extends');

var _extends3 = _interopRequireDefault(_extends2);

var _graphql = require('./graphql');

require('./InputTypeComposer');

require('./EnumTypeComposer');

var _misc = require('./utils/misc');

var _is = require('./utils/is');

var _configAsThunk = require('./utils/configAsThunk');

var _toInputObjectType = require('./utils/toInputObjectType');

var _typeByPath = require('./utils/typeByPath');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// import { deprecate } from './utils/debug';


// extended GraphQLFieldConfigMap


// extended GraphQLFieldConfig


// extended GraphQLOutputType


// Compose Args -----------------------------


// RELATION -----------------------------
/*  strict */
/* eslint-disable no-use-before-define */

class TypeComposer {

  static create(opts) {
    if (!this.schemaComposer) {
      throw new Error('Class<TypeComposer> must be created by a SchemaComposer.');
    }

    let TC;

    if ((0, _is.isString)(opts)) {
      const typeName = opts;
      const NAME_RX = /^[_a-zA-Z][_a-zA-Z0-9]*$/;
      if (NAME_RX.test(typeName)) {
        TC = new this.schemaComposer.TypeComposer(new _graphql.GraphQLObjectType({
          name: typeName,
          fields: () => ({})
        }));
      } else {
        const type = this.schemaComposer.typeMapper.createType(typeName);
        if (!(type instanceof _graphql.GraphQLObjectType)) {
          throw new Error('You should provide correct GraphQLObjectType type definition.' + 'Eg. `type MyType { name: String }`');
        }
        TC = new this.schemaComposer.TypeComposer(type);
      }
    } else if (opts instanceof _graphql.GraphQLObjectType) {
      TC = new this.schemaComposer.TypeComposer(opts);
    } else if ((0, _is.isObject)(opts)) {
      const type = new _graphql.GraphQLObjectType((0, _extends3.default)({}, opts, {
        fields: () => ({})
      }));
      TC = new this.schemaComposer.TypeComposer(type);

      if ((0, _is.isObject)(opts.fields)) {
        TC.addFields(opts.fields);
      }
    } else {
      throw new Error('You should provide GraphQLObjectTypeConfig or string with type name to TypeComposer.create(opts)');
    }

    return TC;
  }

  constructor(gqType) {
    if (!this.constructor.schemaComposer) {
      throw new Error('Class<TypeComposer> can only be created by a SchemaComposer.');
    }

    if (!(gqType instanceof _graphql.GraphQLObjectType)) {
      throw new Error('TypeComposer accept only GraphQLObjectType in constructor');
    }
    this.gqType = gqType;

    // Alive proper Flow type casting in autosuggestions for class with Generics
    // it's required due using <TContext>
    // and Class<> utility type in SchemaComposer
    /* :: return this; */
  }

  /**
   * Get fields from a GraphQL type
   * WARNING: this method read an internal GraphQL instance variable.
   *
   * TODO: should return GraphQLFieldConfigMap<any, any>
   * BUT if setFields(fields: ComposeFieldConfigMap<any, any> | GraphQLFieldConfigMap<any, any>)
   * then flow producess error with such common case TC.setFields(TC.getFields())
   * with following message "Could not decide which case to select"
   * More info about solution
   *  https://twitter.com/nodkz/status/925010361815851008
   *  https://github.com/facebook/flow/issues/2892
   */
  getFields() {
    if (!this._fields) {
      const fields = this.gqType._typeConfig.fields;
      this._fields = (0, _misc.resolveMaybeThunk)(fields) || {};
    }

    return this._fields;
  }

  getFieldNames() {
    return Object.keys(this.getFields());
  }

  /**
   * Completely replace all fields in GraphQL type
   * WARNING: this method rewrite an internal GraphQL instance properties.
   */
  setFields(fields) {
    const prepearedFields = this.constructor.schemaComposer.typeMapper.convertOutputFieldConfigMap(fields, this.getTypeName());

    this._fields = prepearedFields;
    this.gqType._typeConfig.fields = () => (0, _configAsThunk.resolveOutputConfigsAsThunk)(this.constructor.schemaComposer, prepearedFields, this.getTypeName());
    delete this.gqType._fields; // clear builded fields in type
    return this;
  }

  hasField(fieldName) {
    const fields = this.getFields();
    return !!fields[fieldName];
  }

  setField(fieldName, fieldConfig) {
    this.addFields({ [fieldName]: fieldConfig });

    return this;
  }

  /**
   * Add new fields or replace existed in a GraphQL type
   */
  addFields(newFields) {
    this.setFields((0, _extends3.default)({}, this.getFields(), newFields));
    return this;
  }

  /**
   * Add new fields or replace existed (where field name may have dots)
   */
  addNestedFields(newFields) {
    Object.keys(newFields).forEach(fieldName => {
      const fc = newFields[fieldName];
      const names = fieldName.split('.');
      const name = names.shift();

      if (names.length === 0) {
        // single field
        this.setField(name, fc);
      } else {
        // nested field
        let childTC;
        if (!this.hasField(name)) {
          childTC = this.constructor.schemaComposer.TypeComposer.create({
            name: `${this.getTypeName()}${(0, _misc.upperFirst)(name)}`
          });
          this.setField(name, {
            type: childTC,
            resolve: () => ({})
          });
        } else {
          childTC = this.getFieldTC(name);
        }
        childTC.addNestedFields({ [names.join('.')]: fc });
      }
    });

    return this;
  }

  /**
   * Get fieldConfig by name
   * TODO should be GraphQLFieldConfig<any, any>
   * see getFields() method for details
   */
  getField(fieldName) {
    const fields = this.getFields();

    if (!fields[fieldName]) {
      throw new Error(`Cannot get field '${fieldName}' from type '${this.getTypeName()}'. Field does not exist.`);
    }

    return fields[fieldName];
  }

  removeField(fieldNameOrArray) {
    const fieldNames = Array.isArray(fieldNameOrArray) ? fieldNameOrArray : [fieldNameOrArray];
    const fields = this.getFields();
    fieldNames.forEach(fieldName => delete fields[fieldName]);
    this.setFields((0, _extends3.default)({}, fields));
    return this;
  }

  removeOtherFields(fieldNameOrArray) {
    const keepFieldNames = Array.isArray(fieldNameOrArray) ? fieldNameOrArray : [fieldNameOrArray];
    const fields = this.getFields();
    Object.keys(fields).forEach(fieldName => {
      if (keepFieldNames.indexOf(fieldName) === -1) {
        delete fields[fieldName];
      }
    });
    this.setFields(fields);
    return this;
  }

  extendField(fieldName, parialFieldConfig) {
    let prevFieldConfig;
    try {
      prevFieldConfig = this.getField(fieldName);
    } catch (e) {
      throw new Error(`Cannot extend field '${fieldName}' from type '${this.getTypeName()}'. Field does not exist.`);
    }

    if ((0, _is.isFunction)(prevFieldConfig)) {
      throw new Error(`Cannot extend field '${fieldName}' from type '${this.getTypeName()}'. ` + 'FieldConfig declared as a function. ' + 'Such declaration helps to solve hoisting problems between two types which import each other');
    }

    const fieldConfig = (0, _extends3.default)({}, prevFieldConfig, parialFieldConfig);
    this.setField(fieldName, fieldConfig);
    return this;
  }

  reorderFields(names) {
    const orderedFields = {};
    const fields = this.getFields();
    names.forEach(name => {
      if (fields[name]) {
        orderedFields[name] = fields[name];
        delete fields[name];
      }
    });
    this.setFields((0, _extends3.default)({}, orderedFields, fields));
    return this;
  }

  addRelation(fieldName, opts) {
    if (!this.gqType._gqcRelations) {
      this.gqType._gqcRelations = {};
    }
    this.gqType._gqcRelations[fieldName] = opts;

    if (opts.hasOwnProperty('resolver')) {
      this.setField(fieldName, () => {
        return this._relationWithResolverToFC(opts, fieldName);
      });
    } else if (opts.hasOwnProperty('type')) {
      const fc = opts;
      this.setField(fieldName, fc); // was: () => fc
    }

    return this;
  }

  getRelations() {
    if (!this.gqType._gqcRelations) {
      this.gqType._gqcRelations = {};
    }
    return this.gqType._gqcRelations;
  }

  _relationWithResolverToFC(opts, fieldName = '') {
    const resolver = (0, _is.isFunction)(opts.resolver) ? opts.resolver() : opts.resolver;

    if (!(resolver instanceof this.constructor.schemaComposer.Resolver)) {
      throw new Error('You should provide correct Resolver object for relation ' + `${this.getTypeName()}.${fieldName}`);
    }
    if (opts.type) {
      throw new Error('You can not use `resolver` and `type` properties simultaneously for relation ' + `${this.getTypeName()}.${fieldName}`);
    }
    if (opts.resolve) {
      throw new Error('You can not use `resolver` and `resolve` properties simultaneously for relation ' + `${this.getTypeName()}.${fieldName}`);
    }

    const fieldConfig = resolver.getFieldConfig();
    const argsConfig = (0, _extends3.default)({}, fieldConfig.args);
    const argsProto = {};
    const argsRuntime = [];

    // remove args from config, if arg name provided in args
    //    if `argMapVal`
    //       is `undefined`, then keep arg field in config
    //       is `null`, then just remove arg field from config
    //       is `function`, then remove arg field and run it in resolve
    //       is any other value, then put it to args prototype for resolve
    const optsArgs = opts.prepareArgs || {};

    Object.keys(optsArgs).forEach(argName => {
      const argMapVal = optsArgs[argName];
      if (argMapVal !== undefined) {
        delete argsConfig[argName];

        if ((0, _is.isFunction)(argMapVal)) {
          argsRuntime.push([argName, argMapVal]);
        } else if (argMapVal !== null) {
          argsProto[argName] = argMapVal;
        }
      }
    });

    // if opts.catchErrors is undefined then set true, otherwise take it value
    var _opts$catchErrors = opts.catchErrors;
    const catchErrors = _opts$catchErrors === undefined ? true : _opts$catchErrors;


    const resolve = (source, args, context, info) => {
      const newArgs = (0, _extends3.default)({}, args, argsProto);
      argsRuntime.forEach(([argName, argFn]) => {
        newArgs[argName] = argFn(source, args, context, info);
      });

      const payload = fieldConfig.resolve ? fieldConfig.resolve(source, newArgs, context, info) : null;
      return catchErrors ? Promise.resolve(payload).catch(e => {
        // eslint-disable-next-line
        console.log(`GQC ERROR: relation for ${this.getTypeName()}.${fieldName} throws error:`);
        console.log(e); // eslint-disable-line
        return null;
      }) : payload;
    };

    return {
      type: fieldConfig.type,
      description: opts.description,
      deprecationReason: opts.deprecationReason,
      args: argsConfig,
      resolve,
      projection: opts.projection
    };
  }

  /**
   * Get fields from a GraphQL type
   * WARNING: this method read an internal GraphQL instance variable.
   */
  getInterfaces() {
    const interfaces = this.gqType._typeConfig.interfaces;

    if (typeof interfaces === 'function') {
      return interfaces() || [];
    }

    return interfaces || [];
  }

  /**
   * Completely replace all interfaces in GraphQL type
   * WARNING: this method rewrite an internal GraphQL instance variable.
   */
  setInterfaces(interfaces) {
    this.gqType._typeConfig.interfaces = interfaces;
    delete this.gqType._interfaces; // if schema was builded, delete _interfaces
    return this;
  }

  hasInterface(interfaceObj) {
    return this.getInterfaces().indexOf(interfaceObj) > -1;
  }

  addInterface(interfaceObj) {
    if (!this.hasInterface(interfaceObj)) {
      this.setInterfaces([...this.getInterfaces(), interfaceObj]);
    }
    return this;
  }

  removeInterface(interfaceObj) {
    const interfaces = this.getInterfaces();
    const idx = interfaces.indexOf(interfaceObj);
    if (idx > -1) {
      interfaces.splice(idx, 1);
      this.setInterfaces(interfaces);
    }
    return this;
  }

  clone(newTypeName) {
    if (!newTypeName) {
      throw new Error('You should provide newTypeName:string for TypeComposer.clone()');
    }

    const fields = this.getFields();
    const newFields = {};
    Object.keys(fields).forEach(fieldName => {
      newFields[fieldName] = (0, _extends3.default)({}, fields[fieldName]);
    });

    const cloned = new this.constructor.schemaComposer.TypeComposer(new _graphql.GraphQLObjectType({
      name: newTypeName,
      fields: newFields
    }));

    cloned.setDescription(this.getDescription());
    try {
      cloned.setRecordIdFn(this.getRecordIdFn());
    } catch (e) {
      // no problem, clone without resolveIdFn
    }
    this.getResolvers().forEach(resolver => {
      const newResolver = resolver.clone();
      cloned.addResolver(newResolver);
    });

    return cloned;
  }

  /**
   * Get fieldType by name
   */
  getFieldType(fieldName) {
    const field = this.getField(fieldName);
    if (!field) {
      throw new Error(`Type ${this.getTypeName()} does not have field with name '${fieldName}'`);
    }

    return field.type;
  }

  getFieldTC(fieldName) {
    const fieldType = (0, _graphql.getNamedType)(this.getFieldType(fieldName));
    if (!(fieldType instanceof _graphql.GraphQLObjectType)) {
      throw new Error(`Cannot get TypeComposer for field '${fieldName}' in type ${this.getTypeName()}. ` + `This field should be ObjectType, but it has type '${fieldType.constructor.name}'`);
    }
    return this.constructor.schemaComposer.TypeComposer.create(fieldType);
  }

  makeFieldNonNull(fieldNameOrArray) {
    const fieldNames = Array.isArray(fieldNameOrArray) ? fieldNameOrArray : [fieldNameOrArray];
    const fields = this.getFields();
    fieldNames.forEach(fieldName => {
      if (fields[fieldName] && fields[fieldName].type) {
        if (!(fields[fieldName].type instanceof _graphql.GraphQLNonNull)) {
          fields[fieldName].type = new _graphql.GraphQLNonNull(fields[fieldName].type);
        }
      }
    });
    this.setFields(fields);
    return this;
  }

  makeFieldNullable(fieldNameOrArray) {
    const fieldNames = Array.isArray(fieldNameOrArray) ? fieldNameOrArray : [fieldNameOrArray];
    const fields = this.getFields();
    fieldNames.forEach(fieldName => {
      if (fieldNames.indexOf(fieldName) > -1) {
        if (fields[fieldName] && fields[fieldName].type instanceof _graphql.GraphQLNonNull) {
          fields[fieldName].type = fields[fieldName].type.ofType;
        }
      }
    });
    this.setFields(fields);
    return this;
  }

  getType() {
    return this.gqType;
  }

  getTypePlural() {
    return new _graphql.GraphQLList(this.gqType);
  }

  getTypeNonNull() {
    return new _graphql.GraphQLNonNull(this.gqType);
  }

  getInputType() {
    return this.getInputTypeComposer().getType();
  }

  hasInputTypeComposer() {
    return !!this.gqType._gqcInputTypeComposer;
  }

  getInputTypeComposer() {
    if (!this.gqType._gqcInputTypeComposer) {
      this.gqType._gqcInputTypeComposer = (0, _toInputObjectType.toInputObjectType)(this);
    }

    return this.gqType._gqcInputTypeComposer;
  }

  getResolvers() {
    if (!this.gqType._gqcResolvers) {
      this.gqType._gqcResolvers = new Map();
    }
    return this.gqType._gqcResolvers;
  }

  hasResolver(name) {
    if (!this.gqType._gqcResolvers) {
      return false;
    }
    return this.gqType._gqcResolvers.has(name);
  }

  getResolver(name) {
    if (!this.hasResolver(name)) {
      throw new Error(`Type ${this.getTypeName()} does not have resolver with name '${name}'`);
    }
    const resolverMap = this.gqType._gqcResolvers;
    return resolverMap.get(name);
  }

  setResolver(name, resolver) {
    if (!this.gqType._gqcResolvers) {
      this.gqType._gqcResolvers = new Map();
    }
    if (!(resolver instanceof this.constructor.schemaComposer.Resolver)) {
      throw new Error('setResolver() accept only Resolver instance');
    }
    this.gqType._gqcResolvers.set(name, resolver);
    resolver.setDisplayName(`${this.getTypeName()}.${resolver.name}`);
    return this;
  }

  addResolver(opts) {
    let resolver;
    if (!(opts instanceof this.constructor.schemaComposer.Resolver)) {
      resolver = new this.constructor.schemaComposer.Resolver(opts);
    } else {
      resolver = opts;
    }

    if (!resolver.name) {
      throw new Error('resolver should have non-empty name property');
    }
    this.setResolver(resolver.name, resolver);
    return this;
  }

  removeResolver(resolverName) {
    if (resolverName) {
      this.getResolvers().delete(resolverName);
    }
    return this;
  }

  wrapResolver(resolverName, cbResolver) {
    const resolver = this.getResolver(resolverName);
    const newResolver = resolver.wrap(cbResolver);
    this.setResolver(resolverName, newResolver);
    return this;
  }

  wrapResolverAs(resolverName, fromResolverName, cbResolver) {
    const resolver = this.getResolver(fromResolverName);
    const newResolver = resolver.wrap(cbResolver);
    this.setResolver(resolverName, newResolver);
    return this;
  }

  wrapResolverResolve(resolverName, cbNextRp) {
    const resolver = this.getResolver(resolverName);
    this.setResolver(resolverName, resolver.wrapResolve(cbNextRp));
    return this;
  }

  getTypeName() {
    return this.gqType.name;
  }

  setTypeName(name) {
    this.gqType.name = name;
    return this;
  }

  getDescription() {
    return this.gqType.description || '';
  }

  setDescription(description) {
    this.gqType.description = description;
    return this;
  }

  setRecordIdFn(fn) {
    this.gqType._gqcGetRecordIdFn = fn;
    return this;
  }

  hasRecordIdFn() {
    return !!this.gqType._gqcGetRecordIdFn;
  }

  getRecordIdFn() {
    if (!this.gqType._gqcGetRecordIdFn) {
      throw new Error(`Type ${this.getTypeName()} does not have RecordIdFn`);
    }
    return this.gqType._gqcGetRecordIdFn;
  }
  /**
   * Get function that returns record id, from provided object.
   */
  getRecordId(source, args, context) {
    return this.getRecordIdFn()(source, args, context);
  }

  getFieldArgs(fieldName) {
    try {
      const field = this.getField(fieldName);
      return field.args || {};
    } catch (e) {
      throw new Error(`Cannot get field args. Field '${fieldName}' from type '${this.getTypeName()}' does not exist.`);
    }
  }

  hasFieldArg(fieldName, argName) {
    const fieldArgs = this.getFieldArgs(fieldName);
    return !!fieldArgs[argName];
  }

  getFieldArg(fieldName, argName) {
    const fieldArgs = this.getFieldArgs(fieldName);

    if (!fieldArgs[argName]) {
      throw new Error(`Cannot get arg '${argName}' from type.field '${this.getTypeName()}.${fieldName}'. Argument does not exist.`);
    }

    return fieldArgs[argName];
  }

  get(path) {
    return (0, _typeByPath.typeByPath)(this, path);
  }

  deprecateFields(fields) {
    const existedFieldNames = this.getFieldNames();

    if (typeof fields === 'string') {
      if (existedFieldNames.indexOf(fields) === -1) {
        throw new Error(`Cannot deprecate unexisted field '${fields}' from type '${this.getTypeName()}'`);
      }
      this.extendField(fields, { deprecationReason: 'deprecated' });
    } else if (Array.isArray(fields)) {
      fields.forEach(field => {
        if (existedFieldNames.indexOf(field) === -1) {
          throw new Error(`Cannot deprecate unexisted field '${field}' from type '${this.getTypeName()}'`);
        }
        this.extendField(field, { deprecationReason: 'deprecated' });
      });
    } else {
      const fieldMap = fields;
      Object.keys(fieldMap).forEach(field => {
        if (existedFieldNames.indexOf(field) === -1) {
          throw new Error(`Cannot deprecate unexisted field '${field}' from type '${this.getTypeName()}'`);
        }
        const deprecationReason = fieldMap[field];
        this.extendField(field, { deprecationReason });
      });
    }

    return this;
  }
}
exports.TypeComposer = TypeComposer;