'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TypeMapper = undefined;

var _objectWithoutProperties2 = require('babel-runtime/helpers/objectWithoutProperties');

var _objectWithoutProperties3 = _interopRequireDefault(_objectWithoutProperties2);

exports.isOutputType = isOutputType;
exports.isInputType = isInputType;

var _parser = require('graphql/language/parser');

var _language = require('graphql/language');

var _buildASTSchema = require('graphql/utilities/buildASTSchema');

var _keyValMap = require('graphql/jsutils/keyValMap');

var _keyValMap2 = _interopRequireDefault(_keyValMap);

var _invariant = require('graphql/jsutils/invariant');

var _invariant2 = _interopRequireDefault(_invariant);

var _find = require('graphql/jsutils/find');

var _find2 = _interopRequireDefault(_find);

var _values = require('graphql/execution/values');

var _graphql = require('./graphql');

var _json = require('./type/json');

var _json2 = _interopRequireDefault(_json);

var _date = require('./type/date');

var _date2 = _interopRequireDefault(_date);

var _buffer = require('./type/buffer');

var _buffer2 = _interopRequireDefault(_buffer);

var _TypeComposer = require('./TypeComposer');

var _InputTypeComposer = require('./InputTypeComposer');

var _EnumTypeComposer = require('./EnumTypeComposer');

var _Resolver = require('./Resolver');

var _TypeStorage = require('./TypeStorage');

var _is = require('./utils/is');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// eg type Name { field: Int }
// eg. Int, Int!, [Int]
// eg. Int, Float
function isOutputType(type) {
  return type instanceof _graphql.GraphQLScalarType || type instanceof _graphql.GraphQLObjectType || type instanceof _graphql.GraphQLInterfaceType || type instanceof _graphql.GraphQLUnionType || type instanceof _graphql.GraphQLEnumType || type instanceof _graphql.GraphQLNonNull && isOutputType(type.ofType) || type instanceof _graphql.GraphQLList && isOutputType(type.ofType);
} /*  strict */
/* eslint-disable no-use-before-define, class-methods-use-this, no-unused-vars, no-param-reassign */

function isInputType(type) {
  return type instanceof _graphql.GraphQLScalarType || type instanceof _graphql.GraphQLEnumType || type instanceof _graphql.GraphQLInputObjectType || type instanceof _graphql.GraphQLNonNull && isInputType(type.ofType) || type instanceof _graphql.GraphQLList && isInputType(type.ofType);
}

const RegexpOutputTypeDefinition = /type\s[^{]+\{[^}]+\}/im;
const RegexpInputTypeDefinition = /input\s[^{]+\{[^}]+\}/im;
const RegexpEnumTypeDefinition = /enum\s[^{]+\{[^}]+\}/im;

class TypeMapper {

  constructor(schemaComposer) {
    this.basicScalars = new Map([
    // graphql basic types
    ['String', _graphql.GraphQLString], ['Float', _graphql.GraphQLFloat], ['Int', _graphql.GraphQLInt], ['Boolean', _graphql.GraphQLBoolean], ['ID', _graphql.GraphQLID],
    // graphql-compose basic types
    ['JSON', _json2.default], ['Json', _json2.default], ['Date', _date2.default], ['Buffer', _buffer2.default]]);

    if (!schemaComposer) {
      throw new Error('TypeMapper must have SchemaComposer instance.');
    }
    this.schemaComposer = schemaComposer;
  }

  get(name) {
    const basicScalar = this.basicScalars.get(name);
    if (basicScalar) return basicScalar;

    if (!this.schemaComposer.has(name)) {
      return null;
    }

    const schemaType = this.schemaComposer.get(name);
    if ((0, _graphql.isNamedType)(schemaType)) {
      return schemaType;
    }
    return schemaType.getType();
  }

  set(name, type) {
    this.schemaComposer.set(name, type);
  }

  has(name) {
    return this.schemaComposer.has(name);
  }

  getWrapped(str) {
    const inputTypeAST = (0, _parser.parseType)(str);
    return typeFromAST(inputTypeAST, this.schemaComposer);
  }

  createType(str) {
    const astDocument = (0, _parser.parse)(str);

    if (!astDocument || astDocument.kind !== 'Document') {
      throw new Error('You should provide correct type syntax. ' + "Eg. createType('type IntRange { min: Int, max: Int }')");
    }

    const types = parseTypes(astDocument, this.schemaComposer);

    const type = types[0];

    if (type) {
      this.set(type.name, type);
      return type;
    }

    return undefined;
  }

  parseTypesFromString(str) {
    const astDocument = (0, _parser.parse)(str);

    if (!astDocument || astDocument.kind !== 'Document') {
      throw new Error('You should provide correct SDL syntax.');
    }

    return this.parseTypesFromAst(astDocument);
  }

  parseTypesFromAst(astDocument) {
    const typeStorage = new _TypeStorage.TypeStorage();

    for (let i = 0; i < astDocument.definitions.length; i++) {
      const def = astDocument.definitions[i];
      const type = makeSchemaDef(def, this.schemaComposer);
      typeStorage.set(type.name, type);
    }
    return typeStorage;
  }

  convertOutputFieldConfig(composeFC, fieldName = '', typeName = '') {
    let composeType;
    let copyProps;
    let copyArgs;

    if (composeFC instanceof _graphql.GraphQLList || composeFC instanceof _graphql.GraphQLNonNull) {
      return { type: composeFC };
    } else if ((0, _is.isFunction)(composeFC)) {
      return composeFC;
    } else if (composeFC instanceof _Resolver.Resolver) {
      return composeFC.getFieldConfig();
    } else if (composeFC instanceof _TypeComposer.TypeComposer || composeFC instanceof _EnumTypeComposer.EnumTypeComposer) {
      return {
        type: composeFC.getType(),
        description: composeFC.getDescription()
      };
    } else if (Array.isArray(composeFC)) {
      composeType = composeFC;
    } else if (composeFC.type) {
      var _ref = composeFC;
      const type = _ref.type,
            args = _ref.args,
            rest = (0, _objectWithoutProperties3.default)(_ref, ['type', 'args']);

      composeType = type;
      copyProps = rest;
      copyArgs = args;
    } else {
      composeType = composeFC;
    }

    let wrapWithList = 0;
    while (Array.isArray(composeType)) {
      if (composeType.length !== 1) {
        throw new Error(`${typeName}.${fieldName} can accept Array exact with one output type definition`);
      }
      wrapWithList += 1;
      composeType = composeType[0];
    }

    if (composeType instanceof _InputTypeComposer.InputTypeComposer) {
      throw new Error(`You cannot provide InputTypeComposer to the field '${typeName}.${fieldName}'. It should be OutputType.`);
    }

    const fieldConfig = {};
    if (typeof composeType === 'string') {
      if (RegexpInputTypeDefinition.test(composeType)) {
        throw new Error(`${typeName}.${fieldName} should be OutputType, but got input type definition '${composeType}'`);
      }

      if (this.schemaComposer.hasInstance(composeType, _TypeComposer.TypeComposer)) {
        fieldConfig.type = this.schemaComposer.getTC(composeType).getType();
      } else {
        const type = RegexpOutputTypeDefinition.test(composeType) || RegexpEnumTypeDefinition.test(composeType) ? this.createType(composeType) : this.getWrapped(composeType);

        if (!type) {
          throw new Error(`${typeName}.${fieldName} cannot convert to OutputType the following string: '${composeType}'`);
        }
        fieldConfig.type = type;
      }
    } else if (composeType instanceof _TypeComposer.TypeComposer || composeType instanceof _EnumTypeComposer.EnumTypeComposer) {
      fieldConfig.type = composeType.getType();
    } else if (composeType instanceof _Resolver.Resolver) {
      fieldConfig.type = composeType.getType();
    } else {
      fieldConfig.type = composeType;
    }

    if (!fieldConfig.type) {
      throw new Error(`${typeName}.${fieldName} must have some 'type'`);
    }

    if (!(0, _is.isFunction)(fieldConfig.type)) {
      if (!isOutputType(fieldConfig.type)) {
        throw new Error(`${typeName}.${fieldName} provided incorrect OutputType: '${JSON.stringify(composeType)}'`);
      }

      if (wrapWithList > 0) {
        for (let i = 0; i < wrapWithList; i++) {
          fieldConfig.type = new _graphql.GraphQLList(fieldConfig.type);
        }
      }
    }

    if (copyArgs) {
      const args = this.convertArgConfigMap(copyArgs, fieldName, typeName);
      fieldConfig.args = args;
    }

    if ((0, _is.isObject)(copyProps)) {
      // copy all other props
      for (const prop in copyProps) {
        if (copyProps.hasOwnProperty(prop)) {
          fieldConfig[prop] = copyProps[prop];
        }
      }
    }

    return fieldConfig;
  }

  convertOutputFieldConfigMap(composeFields, typeName = '') {
    const fields = {};
    Object.keys(composeFields).forEach(name => {
      fields[name] = this.convertOutputFieldConfig(composeFields[name], name, typeName);
    });

    return fields;
  }

  convertArgConfig(composeAC, argName = '', fieldName = '', typeName = '') {
    let composeType;
    let copyProps;

    if (composeAC instanceof _graphql.GraphQLList || composeAC instanceof _graphql.GraphQLNonNull) {
      return { type: composeAC };
    } else if (composeAC instanceof _InputTypeComposer.InputTypeComposer || composeAC instanceof _EnumTypeComposer.EnumTypeComposer) {
      return {
        type: composeAC.getType(),
        description: composeAC.getDescription()
      };
    } else if (Array.isArray(composeAC)) {
      composeType = composeAC;
    } else if ((0, _is.isFunction)(composeAC)) {
      return composeAC;
    } else if (composeAC.type) {
      var _ref2 = composeAC;
      const type = _ref2.type,
            rest = (0, _objectWithoutProperties3.default)(_ref2, ['type']);

      composeType = type;
      copyProps = rest;
    } else {
      composeType = composeAC;
    }

    let wrapWithList = 0;
    while (Array.isArray(composeType)) {
      if (composeType.length !== 1) {
        throw new Error(`${typeName}.${fieldName}@${argName} can accept Array exact with one input type definition`);
      }
      wrapWithList += 1;
      composeType = composeType[0];
    }

    if (composeType instanceof _TypeComposer.TypeComposer) {
      throw new Error(`You cannot provide TypeComposer to the arg '${typeName}.${fieldName}.@${argName}'. It should be InputType.`);
    }

    const argConfig = {};
    if (typeof composeType === 'string') {
      if (RegexpOutputTypeDefinition.test(composeType)) {
        throw new Error(`${typeName}.${fieldName}@${argName} should be InputType, but got output type definition '${composeType}'`);
      }

      if (this.schemaComposer.hasInstance(composeType, _InputTypeComposer.InputTypeComposer)) {
        argConfig.type = this.schemaComposer.getITC(composeType).getType();
      } else {
        const type = RegexpInputTypeDefinition.test(composeType) || RegexpEnumTypeDefinition.test(composeType) ? this.createType(composeType) : this.getWrapped(composeType);

        if (!type) {
          throw new Error(`${typeName}.${fieldName}@${argName} cannot convert to InputType the following string: '${composeType}'`);
        }

        argConfig.type = type;
      }
    } else if (composeType instanceof _InputTypeComposer.InputTypeComposer || composeType instanceof _EnumTypeComposer.EnumTypeComposer) {
      argConfig.type = composeType.getType();
    } else {
      argConfig.type = composeType;
    }

    if (!argConfig.type) {
      throw new Error(`${typeName}.${fieldName}@${argName} must have some 'type'`);
    }

    if (!(0, _is.isFunction)(argConfig.type)) {
      if (!isInputType(argConfig.type)) {
        throw new Error(`${typeName}.${fieldName}@${argName} provided incorrect InputType: '${JSON.stringify(composeType)}'`);
      }

      if (wrapWithList > 0) {
        for (let i = 0; i < wrapWithList; i++) {
          argConfig.type = new _graphql.GraphQLList(argConfig.type);
        }
      }
    }

    if ((0, _is.isObject)(copyProps)) {
      // copy all other props
      for (const prop in copyProps) {
        if (copyProps.hasOwnProperty(prop)) {
          argConfig[prop] = copyProps[prop];
        }
      }
    }

    return argConfig;
  }

  convertArgConfigMap(composeArgsConfigMap, fieldName = '', typeName = '') {
    const argsConfigMap = {};
    if (composeArgsConfigMap) {
      Object.keys(composeArgsConfigMap).forEach(argName => {
        argsConfigMap[argName] = this.convertArgConfig(composeArgsConfigMap[argName], argName, fieldName, typeName);
      });
    }

    return argsConfigMap;
  }

  convertInputFieldConfig(composeIFC, fieldName = '', typeName = '') {
    let composeType;
    let copyProps;

    if (composeIFC instanceof _graphql.GraphQLList || composeIFC instanceof _graphql.GraphQLNonNull) {
      return { type: composeIFC };
    } else if (composeIFC instanceof _InputTypeComposer.InputTypeComposer || composeIFC instanceof _EnumTypeComposer.EnumTypeComposer) {
      return {
        type: composeIFC.getType(),
        description: composeIFC.getDescription()
      };
    } else if (Array.isArray(composeIFC)) {
      composeType = composeIFC;
    } else if ((0, _is.isFunction)(composeIFC)) {
      return composeIFC;
    } else if (composeIFC.type) {
      var _ref3 = composeIFC;
      const type = _ref3.type,
            rest = (0, _objectWithoutProperties3.default)(_ref3, ['type']);

      composeType = composeIFC.type;
      copyProps = rest;
    } else {
      composeType = composeIFC;
    }

    let wrapWithList = 0;
    while (Array.isArray(composeType)) {
      if (composeType.length !== 1) {
        throw new Error(`${typeName}.${fieldName} can accept Array exact with one input type definition`);
      }
      wrapWithList += 1;
      composeType = composeType[0];
    }

    if (composeType instanceof _TypeComposer.TypeComposer) {
      throw new Error(`You cannot provide TypeComposer to the field '${typeName}.${fieldName}'. It should be InputType.`);
    }

    const fieldConfig = {};
    if (typeof composeType === 'string') {
      if (RegexpOutputTypeDefinition.test(composeType)) {
        throw new Error(`${typeName}.${fieldName} should be InputType, but got output type definition '${composeType}'`);
      }

      if (this.schemaComposer.hasInstance(composeType, _InputTypeComposer.InputTypeComposer)) {
        fieldConfig.type = this.schemaComposer.getITC(composeType).getType();
      } else {
        const type = RegexpInputTypeDefinition.test(composeType) || RegexpEnumTypeDefinition.test(composeType) ? this.createType(composeType) : this.getWrapped(composeType);

        if (!type) {
          throw new Error(`${typeName}.${fieldName} cannot convert to InputType the following string: '${composeType}'`);
        }

        fieldConfig.type = type;
      }
    } else if (composeType instanceof _InputTypeComposer.InputTypeComposer || composeType instanceof _EnumTypeComposer.EnumTypeComposer) {
      fieldConfig.type = composeType.getType();
    } else {
      fieldConfig.type = composeType;
    }

    if (!fieldConfig.type) {
      throw new Error(`${typeName}.${fieldName} must have some 'type'`);
    }

    if (!(0, _is.isFunction)(fieldConfig.type)) {
      if (!isInputType(fieldConfig.type)) {
        throw new Error(`${typeName}.${fieldName} provided incorrect InputType: '${JSON.stringify(composeType)}'`);
      }

      if (wrapWithList > 0) {
        for (let i = 0; i < wrapWithList; i++) {
          fieldConfig.type = new _graphql.GraphQLList(fieldConfig.type);
        }
      }
    }

    if ((0, _is.isObject)(copyProps)) {
      // copy all other props
      for (const prop in copyProps) {
        if (copyProps.hasOwnProperty(prop)) {
          fieldConfig[prop] = copyProps[prop];
        }
      }
    }

    return fieldConfig;
  }

  convertInputFieldConfigMap(composeFields, typeName = '') {
    const fields = {};
    Object.keys(composeFields).forEach(name => {
      fields[name] = this.convertInputFieldConfig(composeFields[name], name, typeName);
    });

    return fields;
  }
}

exports.TypeMapper = TypeMapper; // /////////////////////////////////////////////////////////////////////////////
// From GraphQL-js particles
// /////////////////////////////////////////////////////////////////////////////

function parseTypes(astDocument, schema) {
  const types = [];
  for (let i = 0; i < astDocument.definitions.length; i++) {
    const def = astDocument.definitions[i];
    types[i] = makeSchemaDef(def, schema);
  }
  return types;
}

function typeFromAST(inputTypeAST, schema) {
  let innerType;
  if (inputTypeAST.kind === _language.Kind.LIST_TYPE) {
    innerType = typeFromAST(inputTypeAST.type, schema);
    return innerType && new _graphql.GraphQLList(innerType);
  }
  if (inputTypeAST.kind === _language.Kind.NON_NULL_TYPE) {
    innerType = typeFromAST(inputTypeAST.type, schema);
    return innerType && new _graphql.GraphQLNonNull(innerType);
  }
  (0, _invariant2.default)(inputTypeAST.kind === _language.Kind.NAMED_TYPE, 'Must be a named type.');
  return schema.typeMapper.get(inputTypeAST.name.value);
}

function typeDefNamed(typeName, schema) {
  const type = schema.typeMapper.get(typeName);
  if (type) {
    return type;
  }
  throw new Error(`Cannot find type with name '${typeName}' in TypeMapper.`);
}

function makeSchemaDef(def, schema) {
  if (!def) {
    throw new Error('def must be defined');
  }

  switch (def.kind) {
    case _language.Kind.OBJECT_TYPE_DEFINITION:
      return makeTypeDef(def, schema);
    // case INTERFACE_TYPE_DEFINITION:
    //   return makeInterfaceDef(def);
    case _language.Kind.ENUM_TYPE_DEFINITION:
      return makeEnumDef(def);
    // case UNION_TYPE_DEFINITION:
    //   return makeUnionDef(def);
    // case SCALAR_TYPE_DEFINITION:
    //   return makeScalarDef(def);
    case _language.Kind.INPUT_OBJECT_TYPE_DEFINITION:
      return makeInputObjectDef(def, schema);
    default:
      throw new Error(`Type kind "${def.kind}" not supported.`);
  }
}

function makeInputValues(values, schema) {
  if (!values) return {};
  return (0, _keyValMap2.default)(values, value => value.name.value, value => {
    const type = produceInputType(value.type, schema);
    return {
      type,
      description: (0, _buildASTSchema.getDescription)(value),
      defaultValue: (0, _graphql.valueFromAST)(value.defaultValue, type)
    };
  });
}

function makeFieldDefMap(def, schema) {
  if (!def.fields) return {};
  return (0, _keyValMap2.default)(def.fields, field => field.name.value, field => ({
    type: produceOutputType(field.type, schema),
    description: (0, _buildASTSchema.getDescription)(field),
    args: makeInputValues(field.arguments, schema),
    deprecationReason: getDeprecationReason(field.directives)
  }));
}

function makeEnumDef(def) {
  const enumType = new _graphql.GraphQLEnumType({
    name: def.name.value,
    description: (0, _buildASTSchema.getDescription)(def),
    values: !def.values ? {} : (0, _keyValMap2.default)(def.values, enumValue => enumValue.name.value, enumValue => ({
      description: (0, _buildASTSchema.getDescription)(enumValue),
      deprecationReason: getDeprecationReason(enumValue.directives)
    }))
  });

  return enumType;
}

function makeInputObjectDef(def, schema) {
  return new _graphql.GraphQLInputObjectType({
    name: def.name.value,
    description: (0, _buildASTSchema.getDescription)(def),
    fields: () => makeInputValues(def.fields, schema)
  });
}

function getNamedTypeAST(typeAST) {
  let namedType = typeAST;
  while (namedType.kind === _language.Kind.LIST_TYPE || namedType.kind === _language.Kind.NON_NULL_TYPE) {
    namedType = namedType.type;
  }
  return namedType;
}

function buildWrappedType(innerType, inputTypeAST) {
  if (inputTypeAST.kind === _language.Kind.LIST_TYPE) {
    return new _graphql.GraphQLList(buildWrappedType(innerType, inputTypeAST.type));
  }
  if (inputTypeAST.kind === _language.Kind.NON_NULL_TYPE) {
    const wrappedType = buildWrappedType(innerType, inputTypeAST.type);
    (0, _invariant2.default)(!(wrappedType instanceof _graphql.GraphQLNonNull), 'No nesting nonnull.');
    return new _graphql.GraphQLNonNull(wrappedType);
  }
  return innerType;
}

function produceOutputType(typeAST, schema) {
  const type = produceType(typeAST, schema);
  (0, _invariant2.default)(isOutputType(type), 'Expected Output type.');
  return type;
}

function produceType(typeAST, schema) {
  const typeName = getNamedTypeAST(typeAST).name.value;
  const typeDef = typeDefNamed(typeName, schema);
  return buildWrappedType(typeDef, typeAST);
}

function produceInputType(typeAST, schema) {
  const type = produceType(typeAST, schema);
  (0, _invariant2.default)(isInputType(type), 'Expected Input type.');
  return type;
}

function produceInterfaceType(typeAST, schema) {
  const type = produceType(typeAST, schema);
  (0, _invariant2.default)(type instanceof _graphql.GraphQLInterfaceType, 'Expected Object type.');
  return type;
}

function makeImplementedInterfaces(def, schema) {
  return def.interfaces && def.interfaces.map(iface => produceInterfaceType(iface, schema));
}

function makeTypeDef(def, schema) {
  const typeName = def.name.value;
  return new _graphql.GraphQLObjectType({
    name: typeName,
    description: (0, _buildASTSchema.getDescription)(def),
    fields: () => makeFieldDefMap(def, schema),
    interfaces: () => makeImplementedInterfaces(def, schema)
  });
}

function getDeprecationReason(directives) {
  const deprecatedAST = directives && (0, _find2.default)(directives, directive => directive.name.value === _graphql.GraphQLDeprecatedDirective.name);
  if (!deprecatedAST) {
    return;
  }

  var _getArgumentValues = (0, _values.getArgumentValues)(_graphql.GraphQLDeprecatedDirective, deprecatedAST);

  const reason = _getArgumentValues.reason;

  return reason; // eslint-disable-line
}