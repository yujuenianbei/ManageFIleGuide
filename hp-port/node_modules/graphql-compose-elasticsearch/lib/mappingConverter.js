'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.typeMap = undefined;

var _extends2 = require('babel-runtime/helpers/extends');

var _extends3 = _interopRequireDefault(_extends2);

exports.convertToSourceTC = convertToSourceTC;
exports.propertyToSourceGraphQLType = propertyToSourceGraphQLType;
exports.inputPropertiesToGraphQLTypes = inputPropertiesToGraphQLTypes;
exports.getSubFields = getSubFields;

var _graphqlCompose = require('graphql-compose');

var _graphql = require('graphql-compose/lib/graphql');

var _Geo = require('./elasticDSL/Commons/Geo');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var typeMap = exports.typeMap = {
  text: _graphql.GraphQLString,
  keyword: _graphql.GraphQLString,
  string: _graphql.GraphQLString,
  byte: _graphql.GraphQLInt, // 8-bit integer
  short: _graphql.GraphQLInt, // 16-bit integer
  integer: _graphql.GraphQLInt, // 32-bit integer
  long: _graphql.GraphQLInt, // 64-bit (should changed in future for 64 GraphQL type)
  double: _graphql.GraphQLFloat, // 64-bit (should changed in future for 64 GraphQL type)
  float: _graphql.GraphQLFloat, // 32-bit
  half_float: _graphql.GraphQLFloat, // 16-bit
  scaled_float: _graphql.GraphQLFloat,
  date: _graphqlCompose.GraphQLDate,
  boolean: _graphql.GraphQLBoolean,
  binary: _graphqlCompose.GraphQLBuffer,
  token_count: _graphql.GraphQLInt,
  ip: _graphql.GraphQLString,
  geo_point: _Geo.ElasticGeoPointType, // GraphQLJSON
  geo_shape: _graphqlCompose.GraphQLJSON,
  object: _graphqlCompose.GraphQLJSON,
  nested: new _graphql.GraphQLList(_graphqlCompose.GraphQLJSON),
  completion: _graphql.GraphQLString,
  percolator: _graphqlCompose.GraphQLJSON
};
/* eslint-disable no-use-before-define, no-param-reassign */

function convertToSourceTC(mapping, typeName) {
  var opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

  if (!mapping || !mapping.properties) {
    throw new Error('You provide incorrect mapping. It should be an object `{ properties: {} }`');
  }
  if (!typeName || typeof typeName !== 'string') {
    throw new Error('You provide empty name for type. Second argument `typeName` should be non-empty string.');
  }

  var tc = new _graphqlCompose.TypeComposer(new _graphql.GraphQLObjectType({
    name: `${opts.prefix || ''}${typeName}${opts.postfix || ''}`,
    description: 'Elasticsearch mapping does not contains info about ' + 'is field plural or not. So `propName` is singular and returns value ' + 'or first value from array. ' + '`propNameA` is plural and returns array of values.',
    fields: {}
  }));

  var _mapping$properties = mapping.properties,
      properties = _mapping$properties === undefined ? {} : _mapping$properties;

  var fields = {};
  var pluralFields = opts.pluralFields || [];

  Object.keys(properties).forEach(function (sourceName) {
    var fieldName = sourceName.replace(/[^_a-zA-Z0-9]/g, '_');
    var gqType = propertyToSourceGraphQLType(properties[sourceName], `${typeName}${(0, _graphqlCompose.upperFirst)(fieldName)}`, (0, _extends3.default)({}, opts, {
      pluralFields: getSubFields(sourceName, pluralFields)
    }));
    if (gqType) {
      if (pluralFields.indexOf(sourceName) >= 0) {
        fields[fieldName] = {
          type: new _graphql.GraphQLList(gqType),
          resolve: function resolve(source) {
            if (Array.isArray(source[sourceName])) {
              return source[sourceName];
            }
            return [source[sourceName]];
          }
        };
      } else {
        fields[fieldName] = {
          type: gqType,
          resolve: function resolve(source) {
            if (Array.isArray(source[sourceName])) {
              return source[sourceName][0];
            }
            return source[sourceName];
          }
        };
      }
    }
  });

  tc.addFields(fields);

  return tc;
}

function propertyToSourceGraphQLType(prop, typeName, opts) {
  if (!prop || typeof prop.type !== 'string' && !prop.properties) {
    throw new Error('You provide incorrect Elastic property config.');
  }

  if (prop.properties) {
    // object type with subfields
    return convertToSourceTC(prop, typeName || '', opts).getType();
  }

  if (prop.type && typeMap[prop.type]) {
    return typeMap[prop.type];
  }

  return _graphqlCompose.GraphQLJSON;
}

function inputPropertiesToGraphQLTypes(prop, fieldName) {
  var result = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : { _all: {} };

  if (!prop || typeof prop.type !== 'string' && !prop.properties) {
    throw new Error('You provide incorrect Elastic property config.');
  }

  // mapping
  var _ref = prop,
      properties = _ref.properties;

  if (properties && (0, _graphqlCompose.isObject)(properties)) {
    Object.keys(properties).forEach(function (subFieldName) {
      inputPropertiesToGraphQLTypes(properties[subFieldName], [fieldName, subFieldName].filter(function (o) {
        return !!o;
      }).join('__'), result);
    });
    return result;
  }

  // object type with subfields
  var _ref2 = prop,
      fields = _ref2.fields;

  if (fields && (0, _graphqlCompose.isObject)(fields)) {
    Object.keys(fields).forEach(function (subFieldName) {
      inputPropertiesToGraphQLTypes(fields[subFieldName], [fieldName, subFieldName].filter(function (o) {
        return !!o;
      }).join('__'), result);
    });
  }

  // skip no index fields
  if ({}.hasOwnProperty.call(prop, 'index') && !prop.index) {
    return result;
  }

  if (typeof prop.type === 'string' && fieldName) {
    if (!result[prop.type]) {
      var newMap = {};
      result[prop.type] = newMap;
    }

    var graphqlType = typeMap[prop.type] || _graphqlCompose.GraphQLJSON;
    result[prop.type][fieldName] = graphqlType;
    result._all[fieldName] = graphqlType;
  }

  return result;
}

function getSubFields(fieldName, pluralFields) {
  var st = `${fieldName}.`;
  return (pluralFields || []).filter(function (o) {
    return typeof o === 'string' && o.startsWith(st);
  }).map(function (v) {
    return v.slice(st.length);
  });
}