'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _regenerator = require('babel-runtime/regenerator');

var _regenerator2 = _interopRequireDefault(_regenerator);

var _extends2 = require('babel-runtime/helpers/extends');

var _extends3 = _interopRequireDefault(_extends2);

var _asyncToGenerator2 = require('babel-runtime/helpers/asyncToGenerator');

var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

exports.default = createSearchConnectionResolver;
exports.base64 = base64;
exports.unbase64 = unbase64;
exports.cursorToData = cursorToData;
exports.dataToCursor = dataToCursor;

var _graphqlCompose = require('graphql-compose');

var _utils = require('../utils');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function createSearchConnectionResolver(searchResolver) {
  var _this = this;

  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  var resolver = searchResolver.clone({
    name: `searchConnection`
  });

  resolver.addArgs({
    first: 'Int',
    after: 'String',
    last: 'Int',
    before: 'String'
  }).removeArg(['limit', 'skip']).reorderArgs(['q', 'query', 'sort', 'aggs', 'first', 'after', 'last', 'before']);

  var searchTC = searchResolver.getTypeComposer();
  if (!searchTC) {
    throw new Error('Cannot get TypeComposer from resolver. Maybe resolver return Scalar?!');
  }

  var typeName = searchTC.getTypeName();
  resolver.setType(searchTC.clone(`${typeName}Connection`).addFields({
    pageInfo: getPageInfoTC(opts),
    edges: [_graphqlCompose.TypeComposer.create({
      name: `${typeName}Edge`,
      fields: {
        node: searchTC.get('hits'),
        cursor: 'String!'
      }
    })]
  }).removeField('hits').reorderFields(['count', 'pageInfo', 'edges', 'aggregations']));

  resolver.resolve = function () {
    var _ref = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee(rp) {
      var _rp$args, args, _rp$projection, projection, first, last, before, after, tmp, limit, skip, res, list, hasExtraRecords, cursorMap, edges, result;

      return _regenerator2.default.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              _rp$args = rp.args, args = _rp$args === undefined ? {} : _rp$args, _rp$projection = rp.projection, projection = _rp$projection === undefined ? {} : _rp$projection;

              if (!(!args.sort || !Array.isArray(args.sort) || args.sort.length === 0)) {
                _context.next = 3;
                break;
              }

              throw new Error('Argument `sort` is required for the Relay Connection. According to ' + 'the fields in `sort` will be constructed `cursor`s for every edge. ' + 'Values of fields which used in `sort` should be unique in compound.');

            case 3:
              first = parseInt(args.first, 10) || 0;

              if (!(first < 0)) {
                _context.next = 6;
                break;
              }

              throw new Error('Argument `first` should be non-negative number.');

            case 6:
              last = parseInt(args.last, 10) || 0;

              if (!(last < 0)) {
                _context.next = 9;
                break;
              }

              throw new Error('Argument `last` should be non-negative number.');

            case 9:
              before = args.before, after = args.after;

              delete args.before;
              delete args.after;

              if (!(before !== undefined)) {
                _context.next = 14;
                break;
              }

              throw new Error('Elastic does not support before cursor.');

            case 14:
              if (after) {
                if (!args.body) args.body = {};
                tmp = cursorToData(after);

                if (Array.isArray(tmp)) {
                  args.body.search_after = tmp;
                }
              }

              limit = last || first || 20;
              skip = last > 0 ? first - last : 0;


              delete args.last;
              delete args.first;
              args.limit = limit + 1; // +1 document, to check next page presence
              args.skip = skip;

              if (projection.edges) {
                projection.hits = projection.edges.node;
                delete projection.edges;
              }

              _context.next = 24;
              return searchResolver.resolve(rp);

            case 24:
              res = _context.sent;
              list = res.hits || [];
              hasExtraRecords = list.length > limit;

              if (hasExtraRecords) list = list.slice(0, limit);
              cursorMap = new Map();
              edges = list.map(function (node) {
                var cursor = dataToCursor(node.sort);
                if (cursorMap.has(cursor)) {
                  throw new Error(`Argument \`sort {${args.sort.join(', ')}}\` must be more complex! ` + 'Values from record which are used in `sort` will be used for `cursor` fields. ' + 'According to connection spec `cursor` must be unique for every node.' + 'Detected that two nodes have ' + `the same cursors '${cursor}' with data '${unbase64(cursor)}'. ` + 'You must add more `sort` fields, which provide unique data ' + 'for all cursors in the result set.');
                }
                cursorMap.set(cursor, node);
                return { node, cursor };
              });
              result = (0, _extends3.default)({}, res, {
                pageInfo: {
                  hasNextPage: limit > 0 && hasExtraRecords,
                  hasPreviousPage: false, // Elastic does not support before cursor
                  startCursor: edges.length > 0 ? edges[0].cursor : null,
                  endCursor: edges.length > 0 ? edges[edges.length - 1].cursor : null
                },
                edges
              });
              return _context.abrupt('return', result);

            case 32:
            case 'end':
              return _context.stop();
          }
        }
      }, _callee, _this);
    }));

    return function (_x2) {
      return _ref.apply(this, arguments);
    };
  }();

  return resolver;
}

function getPageInfoTC() {
  var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  var name = (0, _utils.getTypeName)('PageInfo', opts);

  return (0, _utils.getOrSetType)(name, function () {
    return _graphqlCompose.TypeComposer.create(`
      # Information about pagination in a connection.
      type ${name} {
        # When paginating forwards, are there more items?
        hasNextPage: Boolean!

        # When paginating backwards, are there more items?
        hasPreviousPage: Boolean!

        # When paginating backwards, the cursor to continue.
        startCursor: String

        # When paginating forwards, the cursor to continue.
        endCursor: String
      }
    `);
  });
}

function base64(i) {
  return Buffer.from(i, 'ascii').toString('base64');
}

function unbase64(i) {
  return Buffer.from(i, 'base64').toString('ascii');
}

function cursorToData(cursor) {
  if (typeof cursor === 'string') {
    try {
      return JSON.parse(unbase64(cursor)) || null;
    } catch (err) {
      return null;
    }
  }
  return null;
}

function dataToCursor(data) {
  if (!data) return '';
  return base64(JSON.stringify(data));
}