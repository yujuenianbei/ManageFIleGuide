'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends2 = require('babel-runtime/helpers/extends');

var _extends3 = _interopRequireDefault(_extends2);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _dox = require('dox');

var _dox2 = _interopRequireDefault(_dox);

var _fs = require('fs');

var _fs2 = _interopRequireDefault(_fs);

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _graphqlCompose = require('graphql-compose');

var _graphql = require('graphql-compose/lib/graphql');

var _utils = require('./utils');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* eslint-disable no-param-reassign */

var ElasticApiParser = function () {
  function ElasticApiParser() {
    var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    (0, _classCallCheck3.default)(this, ElasticApiParser);

    // avaliable versions can be found in installed package `elasticsearch`
    // in file /node_modules/elasticsearch/src/lib/apis/index.js
    this.apiVersion = opts.apiVersion || opts.elasticClient && opts.elasticClient.transport && opts.elasticClient.transport._config && opts.elasticClient.transport._config.apiVersion || '_default';
    var apiFilePath = _path2.default.resolve(opts.elasticApiFilePath || ElasticApiParser.findApiVersionFile(this.apiVersion));
    var source = ElasticApiParser.loadApiFile(apiFilePath);
    this.parsedSource = ElasticApiParser.parseSource(source);

    this.elasticClient = opts.elasticClient;
    this.prefix = opts.prefix || 'Elastic';
    this.cachedEnums = {};
  }

  (0, _createClass3.default)(ElasticApiParser, [{
    key: 'generateFieldMap',
    value: function generateFieldMap() {
      var _this = this;

      var result = {};
      Object.keys(this.parsedSource).forEach(function (methodName) {
        result[methodName] = _this.generateFieldConfig(methodName);
      });

      var fieldMap = this.reassembleNestedFields(result);
      return (0, _utils.reorderKeys)(fieldMap, ['cat', 'cluster', 'indices', 'ingest', 'nodes', 'snapshot', 'tasks', 'search']);
    }
  }, {
    key: 'generateFieldConfig',
    value: function generateFieldConfig(methodName, methodArgs) {
      var _this2 = this;

      if (!methodName) {
        throw new Error(`You should provide Elastic search method.`);
      }

      if (!this.parsedSource[methodName]) {
        throw new Error(`Elastic search method '${methodName}' does not exists.`);
      }

      var _parsedSource$methodN = this.parsedSource[methodName],
          description = _parsedSource$methodN.description,
          argsSettings = _parsedSource$methodN.argsSettings,
          argsDescriptions = _parsedSource$methodN.argsDescriptions,
          elasticMethod = _parsedSource$methodN.elasticMethod;


      var argMap = this.settingsToArgMap(argsSettings, argsDescriptions);

      return {
        type: _graphqlCompose.GraphQLJSON,
        description,
        args: argMap,
        // eslint-disable-next-line no-unused-vars
        resolve: function resolve(source, args, context, info) {
          var client = context && context.elasticClient || _this2.elasticClient;

          if (!client) {
            throw new Error('You should provide `elasticClient` when created types via ' + '`opts.elasticClient` or in runtime via GraphQL context');
          }

          if (Array.isArray(elasticMethod)) {
            return client[elasticMethod[0]][elasticMethod[1]]((0, _extends3.default)({}, methodArgs, args));
          }
          return client[elasticMethod]((0, _extends3.default)({}, methodArgs, args));
        }
      };
    }
  }, {
    key: 'paramToGraphQLArgConfig',
    value: function paramToGraphQLArgConfig(paramCfg, fieldName, description) {
      var result = {
        type: this.paramTypeToGraphQL(paramCfg, fieldName)
      };
      if (paramCfg.default) {
        result.defaultValue = paramCfg.default;
      } else if (fieldName === 'format') {
        result.defaultValue = 'json';
      }

      if (description) {
        result.description = description;
      }

      return result;
    }
  }, {
    key: 'paramTypeToGraphQL',
    value: function paramTypeToGraphQL(paramCfg, fieldName) {
      switch (paramCfg.type) {
        case 'string':
          return _graphql.GraphQLString;
        case 'boolean':
          return _graphql.GraphQLBoolean;
        case 'number':
          return _graphql.GraphQLFloat;
        case 'time':
          return _graphql.GraphQLString;
        case 'list':
          return _graphqlCompose.GraphQLJSON;
        case 'enum':
          if (Array.isArray(paramCfg.options)) {
            return this.getEnumType(fieldName, paramCfg.options);
          }
          return _graphql.GraphQLString;
        case undefined:
          // some fields may not have type definition in API file,
          // eg '@param {anything} params.operationThreading - ?'
          return _graphqlCompose.GraphQLJSON;
        default:
          // console.log(
          //   // eslint-disable-line
          //   `New type '${paramCfg.type}' in elastic params setting for field ${fieldName}.`
          // );
          return _graphqlCompose.GraphQLJSON;
      }
    }
  }, {
    key: 'getEnumType',
    value: function getEnumType(fieldName, vals) {
      var key = fieldName;
      var subKey = JSON.stringify(vals);

      if (!this.cachedEnums[key]) {
        this.cachedEnums[key] = {};
      }

      if (!this.cachedEnums[key][subKey]) {
        var values = vals.reduce(function (result, val) {
          if (val === '') {
            result.empty_string = { value: '' };
          } else if (val === 'true') {
            result.true_string = { value: 'true' };
          } else if (val === true) {
            result.true_boolean = { value: true };
          } else if (val === 'false') {
            result.false_string = { value: 'false' };
          } else if (val === false) {
            result.false_boolean = { value: false };
          } else if (val === 'null') {
            result.null_string = { value: 'null' };
          } else if (Number.isFinite(val)) {
            result[`number_${val}`] = { value: val };
          } else if (typeof val === 'string') {
            result[val] = { value: val };
          }
          return result;
        }, {});

        var postfix = Object.keys(this.cachedEnums[key]).length;
        if (postfix === 0) postfix = '';else postfix = `_${postfix}`;

        this.cachedEnums[key][subKey] = new _graphql.GraphQLEnumType({
          name: `${this.prefix}Enum_${(0, _graphqlCompose.upperFirst)(fieldName)}${postfix}`,
          values
        });
      }

      return this.cachedEnums[key][subKey];
    }
  }, {
    key: 'settingsToArgMap',
    value: function settingsToArgMap(settings) {
      var _this3 = this;

      var descriptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      var result = {};

      var _ref = settings || {},
          params = _ref.params,
          urls = _ref.urls,
          url = _ref.url,
          method = _ref.method,
          needBody = _ref.needBody;

      if (method === 'POST' || method === 'PUT') {
        result.body = {
          type: needBody ? new _graphql.GraphQLNonNull(_graphqlCompose.GraphQLJSON) : _graphqlCompose.GraphQLJSON
        };
      }

      if (params) {
        Object.keys(params).forEach(function (k) {
          var fieldConfig = _this3.paramToGraphQLArgConfig(params[k], k, descriptions[k]);
          if (fieldConfig) {
            result[k] = fieldConfig;
          }
        });
      }

      var urlList = urls || (url ? [url] : null);

      if (Array.isArray(urlList)) {
        urlList.forEach(function (item) {
          if (item.req) {
            Object.keys(item.req).forEach(function (k) {
              var fieldConfig = _this3.paramToGraphQLArgConfig(item.req[k], k, descriptions[k]);
              if (fieldConfig) {
                result[k] = fieldConfig;
              }
            });
          }
        });
      }

      return result;
    }
  }, {
    key: 'reassembleNestedFields',
    value: function reassembleNestedFields(fields) {
      var _this4 = this;

      var result = {};
      Object.keys(fields).forEach(function (k) {
        var names = k.split('.');
        if (names.length === 1) {
          result[names[0]] = fields[k];
        } else {
          if (!result[names[0]]) {
            result[names[0]] = {
              type: new _graphql.GraphQLObjectType({
                name: `${_this4.prefix}_${(0, _graphqlCompose.upperFirst)(names[0])}`,
                fields: function () {}
              }),
              resolve: function resolve() {
                return {};
              }
            };
          }
          _graphqlCompose.TypeComposer.create(result[names[0]].type).setField(names[1], fields[k]);
        }
      });

      return result;
    }
  }], [{
    key: 'loadFile',
    value: function loadFile(absolutePath) {
      return _fs2.default.readFileSync(absolutePath, 'utf8');
    }
  }, {
    key: 'loadApiFile',
    value: function loadApiFile(absolutePath) {
      var code = void 0;
      try {
        code = ElasticApiParser.loadFile(absolutePath);
      } catch (e) {
        throw new Error(`Cannot load Elastic API source file from ${absolutePath}`);
      }
      return ElasticApiParser.cleanUpSource(code);
    }
  }, {
    key: 'loadApiListFile',
    value: function loadApiListFile(absolutePath) {
      var code = void 0;
      try {
        code = ElasticApiParser.loadFile(absolutePath);
      } catch (e) {
        throw new Error(`Cannot load Elastic API file with avaliable versions from ${absolutePath}`);
      }
      return code;
    }
  }, {
    key: 'findApiVersionFile',
    value: function findApiVersionFile(version) {
      var esModulePath = _path2.default.dirname(require.resolve('elasticsearch'));
      var apiFolder = `${esModulePath}/lib/apis/`;
      var apiListFile = _path2.default.resolve(apiFolder, 'index.js');
      var apiListCode = ElasticApiParser.loadApiListFile(apiListFile);

      // parsing elasticsearch module 13.x and above
      //   get '5.3'() { return require('./5_3'); },
      var re = new RegExp(`\\'${version}\\'\\(\\).*require\\(\\'(.+)\\'\\)`, 'gi');
      var match = re.exec(apiListCode);
      if (match && match[1]) {
        return _path2.default.resolve(apiFolder, `${match[1]}.js`);
      }

      // parsing elasticsearch module 12.x and below
      //   '5.0': require('./5_0'),
      var re12 = new RegExp(`\\'${version}\\':\\srequire\\(\\'(.+)\\'\\)`, 'gi');
      var match12 = re12.exec(apiListCode);
      if (match12 && match12[1]) {
        return _path2.default.resolve(apiFolder, `${match12[1]}.js`);
      }

      throw new Error(`Can not found Elastic version '${version}' in ${apiListFile}`);
    }
  }, {
    key: 'cleanUpSource',
    value: function cleanUpSource(code) {
      // remove invalid markup
      // {<<api-param-type-boolean,`Boolean`>>} converted to {Boolean}
      var codeCleaned = code.replace(/{<<.+`(.*)`.+}/gi, '{$1}');

      // replace api.indices.prototype['delete'] = ca({
      // on api.indices.prototype.delete = ca({
      codeCleaned = codeCleaned.replace(/(api.*)\['(.+)'\](.*ca)/gi, '$1.$2$3');

      return codeCleaned;
    }
  }, {
    key: 'parseParamsDescription',
    value: function parseParamsDescription(doxItemAST) {
      var descriptions = {};
      if (Array.isArray(doxItemAST.tags)) {
        doxItemAST.tags.forEach(function (tag) {
          if (!tag || tag.type !== 'param') return;
          if (tag.name === 'params') return;

          var name = ElasticApiParser.cleanupParamName(tag.name);
          if (!name) return;

          descriptions[name] = ElasticApiParser.cleanupDescription(tag.description);
        });
      }
      return descriptions;
    }
  }, {
    key: 'cleanupDescription',
    value: function cleanupDescription(str) {
      if (typeof str === 'string') {
        if (str.startsWith('- ')) {
          str = str.substr(2);
        }
        str = str.trim();

        return str;
      }
      return undefined;
    }
  }, {
    key: 'cleanupParamName',
    value: function cleanupParamName(str) {
      if (typeof str === 'string') {
        if (str.startsWith('params.')) {
          str = str.substr(7);
        }
        str = str.trim();

        return str;
      }
      return undefined;
    }
  }, {
    key: 'codeToSettings',
    value: function codeToSettings(code) {
      // find code in ca({});
      var reg = /ca\((\{(.|\n)+\})\);/g;
      var matches = reg.exec(code);
      if (matches && matches[1]) {
        return eval('(' + matches[1] + ')'); // eslint-disable-line no-eval
      }
      return undefined;
    }
  }, {
    key: 'getMethodName',
    value: function getMethodName(str) {
      var parts = str.split('.');
      if (parts[0] === 'api') {
        parts.shift();
      }
      if (parts.length === 1) {
        return parts[0];
      } else {
        return parts.filter(function (o) {
          return o !== 'prototype';
        });
      }
    }
  }, {
    key: 'parseSource',
    value: function parseSource(source) {
      var result = {};

      if (!source || typeof source !== 'string') {
        throw Error('Empty source. It should be non-empty string.');
      }

      var doxAST = _dox2.default.parseComments(source, { raw: true });
      if (!doxAST || !Array.isArray(doxAST)) {
        throw Error('Incorrect responce from dox.parseComments');
      }

      doxAST.forEach(function (item) {
        if (!item.ctx || !item.ctx.string) {
          return;
        }

        // method description
        var description = void 0;
        if (item.description && item.description.full) {
          description = ElasticApiParser.cleanupDescription(item.description.full);
        }

        var elasticMethod = ElasticApiParser.getMethodName(item.ctx.string);
        var dottedMethodName = Array.isArray(elasticMethod) ? elasticMethod.join('.') : elasticMethod;

        result[dottedMethodName] = {
          elasticMethod,
          description,
          argsSettings: ElasticApiParser.codeToSettings(item.code),
          argsDescriptions: ElasticApiParser.parseParamsDescription(item)
        };
      });

      return result;
    }
  }]);
  return ElasticApiParser;
}();

exports.default = ElasticApiParser;